:PROPERTIES:
:ID:       704cb428-157c-4498-a339-acc991cbc8cc
:END:
#+title: Algorithms and Data Structures Beginner Course
#+url: https://www.youtube.com/watch?v=8hly31xKli0

* Introduction to Algorithms
- Field of Algorithms - the collection of solutions to common problems in the field of computer science
  - it is important to know these particular problems and to understand similar solutions
- Algorithmic Thinking - is knowing what algorithms you have available to you and when you should apply them
** Algorithms
- Clearly defined problem statement with defined input and output
- Steps need to be distinct and in a very specific order
- A result should be produced and consistent based on a specific input
- It should complete
*** Correctness
- Algorithm is correct, if on all runs of the algorithm with all possible input values result in the expected output values.
- Also for any possible input in order for an algorithm to be correct it must end/terminate.
- correctness is a mathamatical theory proven by mathematical induction
*** Efficientcy
- Measure of efficiency include *time complexity* and *space complexity*
**** Time Complexity
***** How do we determine the complexity of an algorithm?
- Each step in an algorithm can contain its own complexity.
- Example: with Binary Search:
  - one of the steps is to find the middle of the list. This is normally a O(1) operation because most programming languages track the size of lists. If you had to traverse the list to figure out length then the time complexity would be O(n)
  - comparing values is also O(1)
  - splitting the list is O(log n) as half the entries are discarded
  - the complexity is decided by the least efficient step in the algorithm so in this case it would be O(log n)
***** Big O
- Theoretical definition of the complexity of an algorithm as a function of the size
****** O(n^k) Polynomial Runtime
- Algorithm is considered to have a Polynomial Runtime if  worst case scenario is considered to be O(n^k)
- Algorithms that are Polynomial Runtimes are considered to be efficient
******* O(1) Constant Runtime
******* O(n) Linear Runtime
- worst case scenario you take ~n~ tries to find target
- when you know the solution takes at most the same as ~n~
******* O(log n) Logarithmic/Sublinear Runtime
******* O(n^2) Quadratic Runtime
- for any given number of n we carry out n^2 operations
******* O(n log n) Quasilinear Runtime
- example of O(n log n) is merge sort
  - Merge Sort splits each list down the middle until lists are 1 item. Cutting lists in half recursively is a time complexity of O(log n). Then Merge Sort carries out comparison operations for each item (n number of comparisons).
****** O(x^n) Exponential Runtime
- An example of Exponential Runtime in real life is a combination padlock. As you increase the available dials in the padlock the available combinations increase by 10^n if your using numbers 0-9.
- This is a similar principle used for passwords.
******* O(n!) Factorial / Combination Runtime
- Traveling Salesman problem - given a list of cities and the distance of each pair of cities what is the shortest possible route that visits each city and returns to original city
  - this is ~n!~ complexity as places to visit increases combinations available are (n-1)(n-2)(n-3)...
***** Understanding How to Measure Efficiency *Running Time*
- Running Time- Using the number of attempts it takes to get to desired output as a measure of efficiency
- With Linear Search (Johns Algrithm for numbers game)
  - we can compare the best case senario (begining of list)
  - we can compare worst case senario which is the end of the list
- *Good measure of efficiency is the worst case* so all measures of complexity are about the measure of the worst case not the average case
  - this is significant because when evaluating you can theoretically keep on increasing the range in order to analyze function behavior
***** Linear Search
***** Binary Search
**** Space Complexity
- measure of how much working storage or extra storage is needed
***** Iterative Binary Search
- consider first(i) and last(l) pointers. Because the pointer values are changing and we are not manipulating the size of the array in memory this is O(1)  complexity this is constant space
- Space complexity only cares about the additional memory is needed to solve the problem
***** Recursive Binary Search
- because we are creating a new list with every recursive call and the new list is half the size the space complexity is O(log n) but this is language dependent some languages handle space complexity for recursive calls with [[id:1a669718-a51d-4274-96e3-d8962bc025fd][Tail Call Optimization]]
** Search Algorithms
*** Linear Search / Sequential Search / Simple Search
- Start at the begining of the list
- compare to target value
  - if found done
- move sequentially one to the next value
- reach end of list
**** Implementation
#+begin_src python :results output
list = [10,20,30,40]
target = 30
def linear_search(list, target):
    """
    Returns target position else returns None
    """
    for i in range(0,len(list)):
        if (list[i] == target):
            return i
    return None

def verify(index):
    if index is not None:
        print("Target is found at index: ", index)
    else:
        print("Target is not found.")

print(verify(linear_search(list,target)))
#+end_src

#+RESULTS:
: Target is found at index:  2
: None

*** Binary Search
- Input: Sorted list of values
- Output: target position of value or value for when not found
- Steps:
  - Determine middle position of sorted list
  - compare element with target element
  - if match return middle position
  - else compare target with element at current position
    - if less than set start of list to middle position and re-evalute step 1
    - else greater and set end of list to middle position and re-evaluate step 1
  - repeat until target found or list only contians one element
**** Implementation

#+name binary_search
#+begin_src python :results output
list = [10,20,30,40,50,60,77,80,90]
target = 50
def binary_search(list, target):
    """
    Returns target position else returns None
    """
    i = 0
    l = len(list) -1
    while  i <= l :
        m = l+i//2
        if(list[m] == target):
            return m
        elif(list[m] > target):
            l = m - 1;
        else:
            i = m + 1;
    return None;

def verify(index):
    if index is not None:
        print("Target is found at index: ", index)
    else:
        print("Target is not found.")

print(verify(binary_search(list,target)))
#+end_src

#+RESULTS:
: Target is found at index:  4
: None

#+name: recursive_binary_search
#+begin_src python :results output
list = [10,20,30,40,50,60,77,80,90]
target = 40

def recursive_binary_search(list, target): # the recursive function is good if you dont want to know location and just want to verify its is in the list
    if( list == [] ): #is it a good idea to start with end case?
        return False
    mid = len(list)//2
    if list[mid] == target:
        return True
    elif list[mid] < target:
        return recursive_binary_search(list[mid + 1:],target)
    else:
        return recursive_binary_search(list[:mid],target)

def verify(res):
    if res:
        print("Target is found.")
    else:
        print("Target is not found.")

print(verify(recursive_binary_search(list,target)))

#+end_src

#+RESULTS: recursive_binary_search
: Target is found.
: None


* Introduction to Datastructures
** Why do we need more datastructures than a program language provides?
** What is a datastructure?
** Datastructures
*** Arrays
- Arrays are contiguous data structure
- depending on programming language Arrays can be heterogenous or homogenous
  - languags like swift and JavaScript arrays are homogenous
- elements are accessed using an index
#+BEGIN_SRC python :results output
new_list = [1,2,3]
result = new_list[0]
print(result)

if 1 in new_list: print(True)
for n in new_list:
    if n==1:
        print(True)
    break

#+END_SRC

#+RESULTS:
: 1
: True
: True
**** Insert
- Inserting a list item has a linear run time because at the worst case scenario you will have to update the items after the insert to thier new positions
**** Append
- the best case scenario is the ~append~ where adding the item at the end only needs one step
- In python append causes an expansion of the memory allocation called ~resize~. The size of the array is not necessaryily the amount that has been allocated in space. As the array fills its memory it will increase the memory allocated, and the growth pattern follows this item count 0,4,8,16,25,35...
  - over an average append operations take constant space this is called Ammortized Constant Space Complexity
**** Extend
- extend essentially makes a series of append calls until the items in other list have been added to current list
**** Delete
- like insert if an element is deleted from a list every other element has to be shifted to the left (for insert the shift is to the right)
- Delete has an upper bound of O(n) otherwise known as linear runtime
*** Linked List
- A linked list can be a better tool than an Array if the processing happening is more about manipulating (insert,deleting, extending) than it is about accessing a value.
- Each element in the data structure of a linked list is contained in a Node. A node models the item and a reference to the next node in a list. There is the head node (first node) and tail node (last node) in a linked list.
**** Implementation
#+NAME: Node-Class
#+BEGIN_SRC python
class Node:
    """
    An object for storing single node of linked list.
    """

    data = None
    next = None

    def __init__(self, data):
        self.data = data

    def __repr__(self):  # str representation of obj
        return "<Node data: %s>" % self.data

#+END_SRC

#+RESULTS: Node-Class
: None

#+RESULTS: Initialize_Node

#+RESULTS:
: <Node data: 1>

#+NAME: LinkedList-Class
#+BEGIN_SRC python  :noweb yes
<<Node-Class>>

class LinkedList:
    """
    Singly Linked List
    """

    def __init__(self):
        self.head = None

    def is_empty(self):
        return self.head == None

    def size(self):
        current = self.head
        count = 0
        while current:
            count += 1
            current = current.next
        return count

    def append(self, data):
        current = self.head
        if(current == None):
            self.head = Node(data)
        else:
            while(current.next):
                current = current.next
            current.next = Node(data)

    def insert(self, index, data):
        new_node = Node(data)
        current_pos = 0
        current_node = self.head

        if index > self.size():
            raise IndexError("Index out of bounds");
        if index == 0:
            new_node.next = self.head
            self.head = new_node
        else:
            prev_node = None
             #you want to get the node before the position you want to add to not lose prev reference
            while current_pos < index -1:
                current_node = current_node.next
                current_pos +=1

            new_node.next = current_node.next
            current_node.next = new_node

    def search(self, target):
        current = self.head

        while current:
            if current.data == target:
                return current
            else:
                current = current.next

        return None

    def remove(self, target):
        current = self.head
        prev = None
        while current and current.data != target:
            prev = current
            current = current.next

        if prev:
            prev.next = current.next
        else:
            self.head = current.next

    def __repr__(self):
        current = self.head
        nodes = []

        while current:
            if current is self.head:
                nodes.append("(HEAD: %s)" % current.data)
            elif current.next is None:
                nodes.append("(TAIL: %s)" % current.data)
            else:
                nodes.append("(%s)" % current.data)
            current = current.next
        return  '->'.join(nodes)

#+END_SRC

#+RESULTS: LinkedList-Class
: None

#+RESULTS:

#+BEGIN_SRC python :results output :noweb yes
<<LinkedList-Class>>
linked_list = LinkedList()
linked_list.append(1)
linked_list.append(2)
linked_list.append(3)
linked_list.append(4)
linked_list.append(5)
linked_list.append(6)
linked_list.insert(2, 2.5)
linked_list.remove(6)
print("Found: ", linked_list.search(2.5))
print(linked_list)
#+END_SRC

#+RESULTS:
: Found:  <Node data: 2.5>
: (HEAD: 1)->(2)->(2.5)->(3)->(4)->(TAIL: 5)
