:PROPERTIES:
:ID:       704cb428-157c-4498-a339-acc991cbc8cc
:END:
#+title: Algorithms and Data Structures Beginner Course
#+url: https://www.youtube.com/watch?v=8hly31xKli0

* Introduction to Algorithms
- Field of Algorithms - the collection of solutions to common problems in the field of computer science
  - it is important to know these particular problems and to understand similar solutions
- Algorithmic Thinking - is knowing what algorithms you have available to you and when you should apply them
** Algorithms
- Clearly defined problem statement with defined input and output
- Steps need to be distinct and in a very specific order
- A result should be produced and consistent based on a specific input
- It should complete
*** Correctness
- Algorithm is correct, if on all runs of the algorithm with all possible input values result in the expected output values.
- Also for any possible input in order for an algorithm to be correct it must end/terminate.
- correctness is a mathamatical theory proven by mathematical induction
*** Efficientcy
- Measure of efficiency include *time complexity* and *space complexity*
**** Time Complexity
***** How do we determine the complexity of an algorithm?
- Each step in an algorithm can contain its own complexity.
- Example: with Binary Search:
  - one of the steps is to find the middle of the list. This is normally a O(1) operation because most programming languages track the size of lists. If you had to traverse the list to figure out length then the time complexity would be O(n)
  - comparing values is also O(1)
  - splitting the list is O(log n) as half the entries are discarded
  - the complexity is decided by the least efficient step in the algorithm so in this case it would be O(log n)
***** Big O
- Theoretical definition of the complexity of an algorithm as a function of the size
****** O(n^k) Polynomial Runtime
- Algorithm is considered to have a Polynomial Runtime if  worst case scenario is considered to be O(n^k)
- Algorithms that are Polynomial Runtimes are considered to be efficient
******* O(1) Constant Runtime
******* O(n) Linear Runtime
- worst case scenario you take ~n~ tries to find target
- when you know the solution takes at most the same as ~n~
******* O(log n) Logarithmic/Sublinear Runtime
******* O(n^2) Quadratic Runtime
- for any given number of n we carry out n^2 operations
******* O(n log n) Quasilinear Runtime
- example of O(n log n) is merge sort
  - Merge Sort splits each list down the middle until lists are 1 item. Cutting lists in half recursively is a time complexity of O(log n). Then Merge Sort carries out comparison operations for each item (n number of comparisons).
****** O(x^n) Exponential Runtime
- An example of Exponential Runtime in real life is a combination padlock. As you increase the available dials in the padlock the available combinations increase by 10^n if your using numbers 0-9.
- This is a similar principle used for passwords.
******* O(n!) Factorial / Combination Runtime
- Traveling Salesman problem - given a list of cities and the distance of each pair of cities what is the shortest possible route that visits each city and returns to original city
  - this is ~n!~ complexity as places to visit increases combinations available are (n-1)(n-2)(n-3)...
***** Understanding How to Measure Efficiency *Running Time*
- Running Time- Using the number of attempts it takes to get to desired output as a measure of efficiency
- With Linear Search (Johns Algrithm for numbers game)
  - we can compare the best case senario (begining of list)
  - we can compare worst case senario which is the end of the list
- *Good measure of efficiency is the worst case* so all measures of complexity are about the measure of the worst case not the average case
  - this is significant because when evaluating you can theoretically keep on increasing the range in order to analyze function behavior
***** Linear Search
***** Binary Search
**** Space Complexity
- measure of how much working storage or extra storage is needed
***** Iterative Binary Search
- consider first(i) and last(l) pointers. Because the pointer values are changing and we are not manipulating the size of the array in memory this is O(1)  complexity this is constant space
- Space complexity only cares about the additional memory is needed to solve the problem
***** Recursive Binary Search
- because we are creating a new list with every recursive call and the new list is half the size the space complexity is O(log n) but this is language dependent some languages handle space complexity for recursive calls with [[id:1a669718-a51d-4274-96e3-d8962bc025fd][Tail Call Optimization]]
** Search Algorithms
*** Linear Search / Sequential Search / Simple Search
- Start at the begining of the list
- compare to target value
  - if found done
- move sequentially one to the next value
- reach end of list
**** Implementation
#+begin_src python :results output
list = [10,20,30,40]
target = 30
def linear_search(list, target):
    """
    Returns target position else returns None
    """
    for i in range(0,len(list)):
        if (list[i] == target):
            return i
    return None

def verify(index):
    if index is not None:
        print("Target is found at index: ", index)
    else:
        print("Target is not found.")

print(verify(linear_search(list,target)))
#+end_src

#+RESULTS:
: Target is found at index:  2
: None

*** Binary Search
- Input: Sorted list of values
- Output: target position of value or value for when not found
- Steps:
  - Determine middle position of sorted list
  - compare element with target element
  - if match return middle position
  - else compare target with element at current position
    - if less than set start of list to middle position and re-evalute step 1
    - else greater and set end of list to middle position and re-evaluate step 1
  - repeat until target found or list only contians one element
**** Implementation

#+name binary_search
#+begin_src python :results output
list = [10,20,30,40,50,60,77,80,90]
target = 50
def binary_search(list, target):
    """
    Returns target position else returns None
    """
    i = 0
    l = len(list) -1
    while  i <= l :
        m = l+i//2
        if(list[m] == target):
            return m
        elif(list[m] > target):
            l = m - 1;
        else:
            i = m + 1;
    return None;

def verify(index):
    if index is not None:
        print("Target is found at index: ", index)
    else:
        print("Target is not found.")

print(verify(binary_search(list,target)))
#+end_src

#+RESULTS:
: Target is found at index:  4
: None

#+name: recursive_binary_search
#+begin_src python :results output
list = [10,20,30,40,50,60,77,80,90]
target = 40

def recursive_binary_search(list, target): # the recursive function is good if you dont want to know location and just want to verify its is in the list
    if( list == [] ): #is it a good idea to start with end case?
        return False
    mid = len(list)//2
    if list[mid] == target:
        return True
    elif list[mid] < target:
        return recursive_binary_search(list[mid + 1:],target)
    else:
        return recursive_binary_search(list[:mid],target)

def verify(res):
    if res:
        print("Target is found.")
    else:
        print("Target is not found.")

print(verify(recursive_binary_search(list,target)))

#+end_src

#+RESULTS: recursive_binary_search
: Target is found.
: None
